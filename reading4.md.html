<meta charset="utf-8" lang="en">

<div style="text-align: right; line-height: 1.9">
    E85: Reading 4 <br>
    Section 2.9 - 2.10 and 3.1 - 3.2 <br>
    tl;dr version <br>
    June 1, 2020 <br>
</div>

<p style="text-decoration: underline;">
    Section 3.3: Synchronous  Logic Design
</p>

**Sequential Circuits** are all circuits that are not combinational - those circuits whose outputs cannot be determined by simply looking at teh current inputs. As a result, some of these circuits can be quite *crazy*. To keep from this, we emply the notion synchronous sequential circuits and the dynamic discipline.

**Astable Circuit**. Below is what is called a *ring oscillator* made of three inverters connected together in a loop. If X = 1, then Y = 0, Z = 1 and therefore **X = 1**, the initial assumption was incorrect. As a result, the circuit oscillates depending on the propagation delay, which is due to many factors including temperature, manufacturing, the power supply, etc. The system is called astable.

![](image/inverter_loop.jpg)

**Asynchronous Circuits**. Below is a design for an asynchronous design for a D latch. This circuit, like most asynchronous circuits suffers from a **Race Delay Condition.** We ca see that if CLK = D = 1 the latch is transparent and makes Q = 1. When CLK falls, Q should remain 1, however if the inverter off of CLK has a long delay compared the AND and OR gates, then both N1 and Q may fall before $ \overline{CLK} $ rises. This will keep N2 and Q stuck perpetually at zero. These sorts of errors occur when a circuit depends on which of two paths through a logic gate is faster. Seemingly identical circuits can respond very dificult when designed in this way.

![](image/racing.jpg)

**Cyclic Paths** are the key feature that seperates these examples from combinational logic is that there are *cyclic paths*. Therefore, designers break up cyclic paths by inserting registers within cyclic paths. This changes the circuit int a collection of combinational logic and registers. The registers save the state of the system, which change only at the clock edge of a synchronized clock. A sufficiently slow clock can eliminate all possible races.

<span class="pagebreak"></span>

A circuit is defined by its input, output, and functional and timing specifications. **Sequential Circuits** have the following properties.

    - Each has a finite set of discrete states {s1, s2, ...}
    - Synchronous sequential has a clock whose rising edges indiciate when state changes occur. 
    - *Current state* defines the present state of the circuit
    - *Next state* defines the state after the next clock cycle.
    - The functional specification:
        - Details next state.
        - Determines value of each output for each possible combination of input value and current state.
    - The timing specification:
        - Upper bound $ t_{pcq} $ 
        - Lower bout $ t_{ccq} $
            - Time from the rising edge of the clock until the *ouptut* changes.
        - $ t_{setup} $ and $ t_{hold} $
            -  When the *inputs* must be stable relative to the risind edge of the clock.

!!! NOTE: The Rules
    The rules of *synchronous sequential circuit composition* teach that a circuit is synchronous sequential if it consists of interconnected elements such:

        - Every circuit element is either a register or a combinational circuit.
        - At least one circuit element is a register.
        - All registers receive the same clock signal.
        - Every cyclic path contains at least one register.
    
    The simplest circuit the meet this is a flip-flop. Two other common types are finite state machines and pipelines.

!!! ERROR: No Ansynchronous
    Although asynchronous circuits can be more general, they are more troublesome. Nearly all modern digital circuits are essentially synchronous. Sometimes asynchronous circuits are necessary when communicating between different different clocks and when receiving input at arbitrary times.

<span class="pagebreak"></span>

<p style="text-decoration: underline;">
    Section 3.4: Finite State Machines
</p>

![(A) Moore machine; (B) Mealy Machine](image/FSM.jpg)

FSMs get their name because they can be in 1 of $ 2^{k} $ states when the have $ k $ registers. They have:

    - M inputs
    - N outputs
    - k bits of state

On each clock edge, the FSM goes to the next state, which was computed based on the current state and the inputs. 

    1. Moore Machine: outputs depend only on the current state of the machine.
    2. Mealy Machine: outputs depend on both the current state and the current inputs.

**FSM Design Example: Traffic Light (The Book Does This Better):**

The plan is as follows:
    - Install two traffic lights with sensors $ T_{A} $ and $ T_{B} $. The sensors return TRUE if traffic is there and FALSE otherwise.
    - Install two lights $ L_{A} $ and $ L_{B} $ with digital inputs to specify red, green, and yellow.
    - Hence, two inputs T and outputs L.

First we should sketch the *state transistion diagram* which indicates all possible states of the system and the transistion between states. 

![State Transition Diagram](image/state_transition.jpg)

    - Circles represent states and arcs represent transitions between states.
    - Transistions occur at the rising edge of the clock, but the clock is implicit and not shown.
        - Clock: When a transition occurs
        - Diagram: Which transitions occur
    - The reset arc implies that the system will enter state s0 from any state give the reset signal.
    - If multiple arcs leave, the signal for that path is labelled.
    - If only a single arc leaves the transistion occurs no matter the inputs.

The next step is to turn the diagram into a **state transition table**. As seen below, this table contains what the next state should be for every current state and input.

![](image/FSMtables.jpg)

    - X's represent *don't care* signals whenever the next state does not depend on a particular input.
    - Reset is omitted.
    - Instead, use resettable flip-flops that always go to state s0 on reset.

<span class="pagebreak"></span>

After this, we have to make **binary encodings** to represent a real circuit. Above table shows a simple encodings mapping the states and the outputs. These encodings can be substituted into the state transition table which becomes a truth table for the system. It is simple to read off boolean equations from this table.

![](image/FSMtables2.jpg)

$$ S'_{1} = \overline{S_{1}} S_{0} + S_{1} \overline{S_{0}} \overline{T_{B}} + S_{1} \overline{S_{0}} T_{B} $$
$$ S'_{0} = \overline{S_{1}} \overline{S_{0}} \overline{T_{A}} + S_{1} \overline{S_{0}} \overline{T_{B}} $$

Of course, these may be simplifed into **next state equations:**

$$ S'_{1} = S_{1} \; XOR \; S_{0} $$
$$ S'_{0} = \overline{S_{1}} \overline{S_{0}} \overline{T_{A}} + S_{1} \overline{S_{0}} \overline{T_{B}} $$

An **output table** can be drawn as below and similarly read for its boolean equations.

![](image/FSMtables3.jpg)

$$ L_{A1} = S_{1} $$
$$ L_{A0} = \overline{S_{1}} S_{0} $$
$$ L_{B1} = \overline{S_{1}} $$
$$ L_{B2} = S_{1} S_{2} $$

<span class="pagebreak"></span>

The final case is to draw the circuit. The image for this is extremely valuable.

![](image/FSMcircuit.jpg)

Begin with a 2-bit register. One each clock edge it copies the next state to become the state. This register receives the reset to initialize the FSM for startup. Next, draw the next state logic based on the S' boolean equations. Finally draw the output logic from the L equations. For convenience, below is a timing diagram where the CLK has a five second period.

<span class="pagebreak"></span>

!!! NOTE: A note on encodings
    In the example, state encodings were determined arbitrarily. Different choices means different circuit. There is no simple way to find the best encoding, this optimization is generally completed by CAD tools that search the large design space. The most important distinction is:
    
        - **Binary Encoding**: Each state represented by binary number. A system with K states need only $ \log_2 K $ bits.
        - **One-Hot Encoding**: Each state gets a seperate bit. Only one bit is TRUE or "hot" at any given time. Each state is stored in a flip-flop, which means more hardware but often allows for simpler next-state and output logic.

The examples up to this point have been Moore Machines - output only depends on current state. **Mealy Machines** are similar but may depend on inputs and current state. As a result, for Mealy Machines, the outputs are labeled on the arcs rather than circles for a state transition diagram. Often this can reduce the number of states. See page 132 in the book for a comparision between the Moore and Mealy Machines.

![](image/MM.jpg)

Designing FSMs is easier if problems can be broken into smaller FSMs. This practice is called *factoring*. An example would be adding functionality to the traffic light example. Rather than building in a parade mode that keeps the system in a single configuration, a mode switching FSM can be designed and connected to the light FSM.  

![](image/factoring.jpg)

<span class="pagebreak"></span>

**Deriving an FSM from Schematic** is important. Here are the general steps (pg 137):

    - Examine circuit, starting inputs, outputs, and state bits.
    - Write next state and output equations.
    - Create next state and output tables.
    - Reduce the next state table to eliminate unreachable states.
    - Assign each valid state bit combination a name.
    - Reqrite next state and output tables with state names.
    - Draw state transistion diagram.
    - State in words what the FSM does.

**Summary** FSMs are a powerful means to systematically design sequential circuits from written specification. The design method is:

    - Indentify inputs and outputs.
    - Sketch a state transition diagram.
    - For a Moore Machine:
        - Write a state transistion table.
        - WRite an output table.
    - For a Mealy Machine:
        - Wrate a combined state transition and output table.
    - Select state encodings - your selection affects the hardware design.
    - Write Boolean equations for the next state and output logic.
    - Sketch the circuit schematic

<script src="markdeep-thesis/lib/bindery/2.2.9/bindery.min.js"></script>
<script>
    markdeepThesisOptions = {
        view: "print",
        titlePage: titlePage,
        fontSize: 10.5,
        markdeepDiagramScale: 0.8
    }
</script>
<script src="markdeep-thesis/markdeep-thesis.js"></script>
<script src="markdeep-thesis/lib/markdeep/1.09/markdeep.min.js" charset="utf-8"></script>