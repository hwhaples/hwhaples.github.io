<meta charset="utf-8" lang="en">

<div style="text-align: right; line-height: 1.9">
    E85: Reading 5 <br>
    Section 3.5 - 3.7 <br>
    tl;dr version <br>
    June 9, 2020 <br>
</div>

<p style="text-decoration: underline;">
    3.5 Timing of Sequential Logic
</p>

***Remember*** the roll of a flip-flop is to copy input D to output Q on the rising edge of the clock. This process is called **sampling**.

If the value of D is stable at the rising clock edge this is clearly defined. But, *what if the value of D is unstable?* This is like trying to take a picture of a moving object. The speed of how quickly a sequential element can capture information like a camera is defined by **setup time** before the clock rising edge and **hold time** after the rising edge of the clock. Just like how the static discipline limits logic levels outside the forbidden zone, the **dynamic discipline** limits designers to using signals that change outside the limiting time.

!!! NOTE: Dynamic Discipline
    Think of time as discrete units called *clock cycles.* We are only concerned about the final value at the end of the clock cycle, otherwise the signal can oscillate. As a result the signal A is A[n] at the end of the nth clock cycle and is stable. A(t) at any given time may be any value.

The meet this discipline, the clock period must be long enough for all signals to settle. This is more complex because the clock does not reach every flip-flop at the same time. To handle real world random time input, we must use a *synchronizer* to convert asynchronous input.

    - **clock-to-Q contamination delay**, tccq, time after which a value may begin to change.
    - **clock-to-Q propagation delay**, tpcq, time after which signals must have settled to final value.

In order to sample correctly, a circuit have a:

    - **setup time**: Inputs must be stable for this time before the clock rising edge.
    - **hold tim**: Outputs must be stable for this long after the clock rising edge.
    - The sum of these quantities is the *aperture time*

<span class="pagebreak"></span>

To measure system timing begin with the *clock period*, the time between rising edges of a repetitive clock signals. The reciprocal, fc = 1/Tc, is the **clock frequency**.

![](image/timing.jpg)


**Setup Time Constraint** 

In the combined timing diagram below, it is shown that:

$$ T_{c} \geq t_{pcq} + t_{pd} + t_{setup} $$

Usually, only the propagation delay, $ t_{pd} $, is under the control of the designer which may be computed by rearranging (see below). The term *sequencing overhead* is used to describe $ t_{pcq} + t_{setup} $, the time that flip-flops cuts into usable time.

$$ t_{pd} \leq T_{c} - (t_{pcq} + t_{setup}) $$

By this equation, if the propagation delay through the combinational logic is too great, D may not have settled when R samples it. Hence, R may be illegal or incorrect. The problem is fixed with increasing period or redisigning the circuit to have shorter propagation delay. This is the setup time constraint.

**Hold Time Constraint**

$$ t_{ccq} + t_{cd} \geq t_{hold} $$

Usually only contamination delay is within the designer's choice which is found by rearranging.

$$ t_{cd} \geq t_{hold} - t_{ccq} $$

Assuming that any logic elements can be connected without introducing timing problems, if two flip-flops connect, then $ t_{cd} $ = 0 because there is not combinational logic between the connections. This means by the above equation, in a reliable flip-flop, hold time is shorter than contamination delay. This is a **good assumption** and simplification such $ t_{hold} \leq t_{ccq} $.

Hold time constraints are critically important because if they are violated the only solution is redesigning the circuits. Setup time constraints can be solved by fixing the clock. *Hold time violations* can cost millions. 

!!! Note: Summary so far
    - The setup and hold time constraints on sequential circuits dictate the maximum and minimum delays of the combinational logic between flip-flops.
    - Modern flip flops have a minimum combinational logic delay of 0; they may be placed back to back.
    - The maximum delay constraint limits the number of consecutive gates on the critical path of a high-speed circuit. 

**Metastability**

When a flip-flop samples an input that is changing during the aperture, the output may take a value between 0 and $ V_{DD} $ that may be in the forbidden zone. This is called a **metastable** state which will eventually resolve to a stable state. However, the *resolution time* to reach the stable state is unbounded.

The resolution time is $ t_{res} $. If input changes outside the aperture, $ t_{res} = t_{pcq} $. If it changes inside the aperature, the time is much longer. This time is statistical and governed to be longer than some time t by:
$$ P(t_{res} > t) = \frac{T_0}{T_{c}} e^{\frac{-t}{\tau}} $$

$ T_{c} $ is the clock period, and $ T_{0} $ and $\tau$ are characteristic of the flip-flop. $ T_{0} / T{c} $ is the probability that input during the aperature time. This decreases with cycle time.

!!! NOTE: Summary
    Input to a bistable device can take on a metastable state. The amount of time required to resolve is unbounded, but the probability of remaining metastable drops exponentially as time increases. If we wait long enough, longer than $ t_{pcq} $ we can expect with high probability that the flip-flop will reach a valid logic level.

**Synchronizers** 

Synchronizers are devices that take asynchronous input and guarantee good logic levels. The device takes an asynchronous input D and clock CLK. It produces an output Q within some bounded time that has a valid logic value with an extremely high probability. If D is stable during the aperture, the Q is the same as D. Otherwise, Q is HIGH or LOW but not metastable. 

Above is a simple synchronizer. A synchronizer fails if its output is metastable. This is if $ t_{res} > T_{c} - t_{setup} $ , or if D2 has not resolved to a valid level by the time it must setup at F2. Failure probability is:

$$ P(fail) = \frac{T_0}{T_c}e^{-\frac{T_c - t_{setup}}{\tau}} $$

If D changes N times per second, the probability of failure per second is given:

$$ \frac{P(fail)}{sec} = N \frac{T_0}{T_c}e^{-\frac{T_c - t_{setup}}{\tau}} $$

System reliability if given as **mean time between failures** (MTBF). It is the reciprocal of the above equation.

$$ MTBF = \frac{1}{P(fail)/sec} = \frac{T_{c} e^{\frac{T_c - t_{setup}}{\tau}}}{NT_0}$$


<p style="text-decoration: underline;">
    3.6 Parallelism
</p>

System speed is defined by the latency and throughput of information through it. A **token** is a group of inputs that are processed to make a group of outputs**. The **latency** measures the time for one token to pass through the system from start to end. The **throughput** is the number of tokens per unit time.

Throughput may be improved by processing several tokens at the same time. This is called parallelism.

    - Spacial Parallelism: Multiple copies of the hardware are provided so tasks can be done at the same time.
    - Temporal Parallelism: Task is broken into stages multiple tasks are spread across the stages, but each task must pass through each stage. (**Pipelining**)

!!! NOTE: Comparison
    Consider a task with latency L. 
        - Throughput is 1/L with no parallelism.
        - Throughput is N/L with N copies of the hardware.
        - Throughput is N/L with one copy of hardware if ideally broken into N steps of equal length.
    Pipelining is realized in hardware by placing registers between blocks of combinational logicto divide the logic into shorter stages that can run on a faster clock.

Compare the figures with and without pipelining. Figure 1 has a throughput of 1 / 9.5 ns = 105 MHz (clock-to-Q propagation delay of 0.3 ns and setup time of 0.2 ns). Figure 2 has throughput 182 MHz. Figure 3 has throughput 222 MHz. 

The bane of parallelism are **dependencies**. This means a task depends on a previous task to be completed and input. This does not allow these tasks to be parallelized.

There is a summary on page 161 of this and reading 4.

<script src="markdeep-thesis/lib/bindery/2.2.9/bindery.min.js"></script>
<script>
    markdeepThesisOptions = {
        view: "print",
        titlePage: titlePage,
        fontSize: 10.5,
        markdeepDiagramScale: 0.8
    }
</script>
<script src="markdeep-thesis/markdeep-thesis.js"></script>
<script src="markdeep-thesis/lib/markdeep/1.09/markdeep.min.js" charset="utf-8"></script>