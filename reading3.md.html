<meta charset="utf-8" lang="en">

<div style="text-align: right; line-height: 1.9">
    E85: Reading 1 <br>
    Section 2.9 - 2.10 and 3.1 - 3.2 <br>
    tl;dr version <br>
    May 28, 2020 <br>
</div>
<p style="text-decoration: underline;">
    Section 2.2: Boolean Equations
</p>
A **boolean equation** is a mathematical equation that deals only with variables that are either TRUE or FALSE. It helps to begin with some terminology:

    - The **complement** of a variable $ A $ is its inverse $ \overline{A} $
    - Together, the variable and its complement are called a **literal**.
    - $ A $ is the **true form**
    - $ \overline{A} $ is the **complementary form**. 

From here we can get into how these variables can interact:

    - The AND function is called the **product** or **implicit**. 
    - A **minterm** is a product expression that contains all relevant variables.
        - i.e. For 3 variables, a minterm could be $ A B \overline{C} $ but not $ A \overline{B} $.
    - The OR function is called the **sum**.
    - The **maxterm** is a sum that involves all of the inputs to the function.
        - i.e. For 3 variables, a maxterm could be $ A + B + \overline{C} $ but not $ A + \overline{B} $.

!!! NOTE: Order of Operations
    The order of operations for boolean equations is:
        1. NOT
        2. AND (product)
        3. OR (sum)
    $$ \overline{A}B + BC \overline{D} = ((\overline{A})B) + (BC (\overline{D}))$$

!!! ERROR: Minterm and Maxterm
    It is easy to remember minterm and maxterm. A minterm has the minimum number of terms possible for the number of variables in the function (it is a monomial). The maxterm has the maxmimum number of independent terms as a polynomial.


<span class="pagebreak"></span>

The **sum-of-products** form allows us to write a boolean expression for any truth table. The image below shows a two input truth table.

Each row's corresponding minterm is true for that row's inputs (i.e. $ A = 0 $ and $ B = 0 $ then the minterm is $ \overline{A} \overline{B} $ becuase $ \overline{A} \overline{B} $ is TRUE for these inputs.)

![](image/truth_table1.jpg)

To write a boolean equation to describe the truth table, simply take the minterm of all rows that output TRUE and ***sum*** them. From the example image the result would be:
        $$ Y = \overline{A}B + AB $$

An alternative method exists called the **product-of-sums* form that works oppositely to result in an equally correct answer. Simply write the maxterms for each row of a truth table and select and product all of the rows that output 0.

<p style="text-decoration: underline;">
    Section 2.3: Boolean Algebra
</p>
A shortcomming of both truth table forms is that the result is not often the simplest equation for the intended output. To simplify these boolean equations, we must use boolean Algebra. The governing axioms of boolean algebra are below.

![](image/axioms.jpg)

The table below contains boolean theorems of one variable followed by brief descriptions.
    
    - T1 = *identity theorem*, If an input to AND is always true, the output will be A. If the input or OR is always false, the output will be A. You may remove the gate and replace with wire.
    - T2 = *null element theorem*, A AND 0 is always 0. A OR 1 is always 1. Wires tied to these outputs may replace the gates.
    - T3 = *idempotency*, a variable AND itself is itsellf. A variable OR itself is itself.
    - T4 = *involution*, complementing a variable twice returns the original variable.
    - T5 = *complement theorem*, a variable AND its complement is 0. A variable OR its complement is 1.

![Theorems of One Variable](image/theorems1.jpg)

There are also theorems of several variables summarized below:

![Theorems of Several Variables](image/theorems2.jpg)

!!! NOTE: De Morgan's Theorem
    **De Morgan's Theorem**, T12, is particularly important. It states a NAND gate is equivalant to an OR gate with inverted inputs.  The inversion circles in the gates are called *bubbles*. You could image **pushing** the bubble through the gate from one side to another. This flips the body of the gate from AND to OR or vice versa.

The rules for **bubble pushing** are as follows:

    - Pushing bubbles changes the body of the gate from AND or OR or vice-versa.
    - Pushing a bubble from the output back to the inputs places bubbles on all gate inputs.
    - Pushing bubbles on all gate inputs forward to the output places a bubble on the output. (***You must invert all inputs***)

<span class="pagebreak"></span>
You may use the theorem's of boolean algebra to simplify boolean expressions. The goal is to combine terms knowing the relationship $ PA + P \overline{A} = P $ where P is any involved variable(s). The *minimized* form will have the least number of implicants (monomials making up a polynomial), as well as the least number of literals.

Sometimes it is better to expand an implicant first, it may produce terms for better simplification further down. Doing this by hand can have quite a few trial and error steps. Read section 2.7 on **Karbaugh maps** to make the process easier.

<p style="text-decoration: underline;">
    Section 3.1: Introduction
</p>

With an understanding of the logic gates, we will now be able to analyze and design **sequential logic**. The key feature of sequential logic is that outputs depend on both current and prior inputs - the logic has **memory**. Memory is useful for both explicitly remembering previous inputs or to distill into smaller amounts of information called the **state.** 

The goal for this chapter is:

    - Study latches and flip-flops; simple sequential circuits that can store one bit of data.
    - Simplify the complex design space of sequential circuits to only *synchronous sequential circuits* made up of combinational logic and banks of flip-flops.
    - Analyze the speed of sequential circuits and use parallelism to increase speed.


<p style="text-decoration: underline;">
    Section 3.2: Latches and Flip-Flops
</p>

Memory is made through **bistable** elements - elements with two stable states. A simple bistable element is the *cross-coupled* inverter. The circuit (seen below) can be analyzed as follows.

![Cross-Coupled Inverter](image/cc_inverter.jpg)

    - Case 1: Q = 0; I2 recieves FALSE and thus $ \overline{Q} $ is true. The system is stable since I1 recieves TRUE and returns FALSE for $ Q $ as expected.
    - Case 2: Q = 1; I2 recieves TRUE and produces FALSE on $ \overline{Q} $. Checking stability, as expected I1 recieves FALSE and returns $ Q $ as TRUE.

This circuit has two stable states, and thus caries $ \log_2 N = 1 $ bit of information.

!!! ERROR: Metastable
    A warning, is that there exists a third stable state directly in between 0 and 1. This is called *metastable* and is effectively an unstable equilibrium point for the circuit.

<span class="pagebreak"></span>

The cross-coupled inverter is bad because it cannot have any input. Far better are latches and flip-flops. The first is the **SR Latch**. To understand it, work out the truth table.

![SR Latch](image/SRLatch.jpg)

    - Case 1: **R = 1, S = 0**; N1 sees at least 1 true, so $ Q $ = FALSE. N2 sees Q and S FALSE, and thus $ \overline{Q} $ = TRUE.
    - Case 2: **R = 0, S = 1** ; N2 gets at least one TRUE so $ \overline{Q} $ = FALSE. N1 sees both FALSE and returns $ Q $ = TRUE.
    - Case 3: **R = 1, S = 1**; Both $ Q $ and $ \overline{Q} $ are FALSE since each sees at least one TRUE.
    - Case 4: **R = 0, S = 0**; dificult roundabout case where we cannot be sure because we do not know the *previous* value of either R or S. The subcases are:
        - **Case 4A: Q = 0**; S and $ Q $ FALSE, meaning N2 puts TRUE on $ \overline{Q} $ and $ Q $ is FALSE as assumed.
        - **Case 4B: Q = 1**; N2 produces FALSE on $ \overline{Q} $ since $ Q $ is true. $ Q $ results TRUE as assumed.
    
!!! NOTE: Memory
    As you can see, the 4th case supposes some previous value of Q and asserts it when the circuit is OFF (R=0;S=0). The system has memory of the previous configuration of Q, $ Q_{prev} $ that it has asserted. It is controllable; asserting R resets to 0, asserting S sets to 1. Asserting neither keeps the old value. Don't assert both.

The SR latch is weird about asserting both S and R - it conflates what and when, which are better left seperate. So instead use the **D-latch**. A summary figure of the D latch is below.

![D-Latch(image/DLatch.jpg)]

    - The D latch has two inputs, *D* for **Data** (the what) and *CLK* for **Clock** (then when).
    - Reviewing the truth table we see:
        - The CLK controls when data may flow: C
            - CLK = 1, the latch Data D flows to Q and is *transparent* as if the gate is simply a buffer.
            - CLK = 0, the latch is *opaque*, not data flows.
        - D latch updates continuously when CLK = 1.

<span class="pagebreak"></span>
Sometimes it is better if the gate only updates when you want it to instead of continuously. This is why we have the **D Flip Flop.** It is two **D Latches** controlled by complementary clocks.

![D Flip-Flop](image/dff.jpg)

    - First latch is called the *master*, the other is the *slave*.
    - When the CLK = 0, the master is transparent, the slave is opaque; D propagates to N1. 
    - When the CLK = 1, the master is opaque and the slave is transparent; N1 propagates to Q.
    - Whatever D was immediately before the clock rises to from 0 to 1 is immediately copied to Q after the clock rises.

!!! ERROR: REMEMBER THIS AT ALL COSTS
    ***A D Flip-Flop copies D to Q on the rising edge of the clock and remembers its state at all other times.*** (Sometimes the rising edge of the clock is called clock edge.)

Putting flip-flops together to remember more data is called a **register** if they all share a common clock and thus update at the same time. An N-bit register has N flip-flops.

<span class="pagebreak"></span>

**Enabled Flip Flops** allow the result to be updated only some of the time instead of every rising clock cycle. It does this with an EN - *enable* port. Two implementations and the schematic are below.
    - Implementation A: A [multiplexer](https://en.wikipedia.org/wiki/Multiplexer) chooses to pass the value at D or to recycle the previosu value.
    - The clock is gated and only toggles the flip flop when enabled. (Dangerous because of possible clock desynchronization).

![Enabled Flip Flop](image/enflipflop.jpg)

**Resetable Flip Flops** allow normal operation to drop and the data to be reset to 0 by asserting a reset symbol. They may be:
    - Synchronous: resets with the clock.
    - Asynchronous: Resets immediately.

![Synchronous Resetable Flip Flop](image/resetflipflop.jpg)

When $ \overline{Reset} $ is FALSE the AND gate forces a 0 over the data. When $ \overline{Reset} $ is TRUE, the AND gate passes D. $ \overline{Reset} $ is **active low**, meaning that reset occurs at 0, not 1, and the 1 would have to always be asserted for normal operation. Adding an inverter can correct this.

Settable flip flops also exist to load a 1 onto system memory. All these types of flip flops may be grouped into N-bit registers.

To save cost, a single D-latch can actually be made with transistors. This is better than logic gates which use a large number of transistors for a single latch (42). Using a **Transmission Gate** 
    
    - **Transparent: $ CLK = 1 $ and $ \overline{CLK} = 0 $
    - **Opaque:  $ CLK = 0 $ and $ \overline{CLK} = 1 $

![](image/transistor_network4.jpg)

The limitation of the latch:

    - *Floating output*: Q is not held by any gate if the latch is opaque and its value will change or float due to leakage, noise, etc.
    - *No buffers*: It is possible that the spike of pulling D to 0 can turn on the nMOS transistor and make the latch transparent even when CLK = 0. Similarly, a spike in D above $ V_{DD} $ can turn on the pMOS transistor and open the gate unintentionally.
    - Both input and ouput have troubles that make this not viable in the real world. The figures below show more robust iterations used in real hardware.

![Real latch/flip-flop - 20 transistors total](image/realff.jpg)

**Summary:** Latches and flip-flops are the building blocks of sequential circuits.

    - D-latch is *level sensitive*; output controlled by the level of the clock (1,0)
        - Transparent when CLK = 1, allowing input D to flow to output Q.
    - D Flip-Flop is *edge-triggered*; output changes only when the clock changes.
        -  ***D Flip-Flop copies D to Q on the rising edge of the clock and remembers its state at all other times.***


<script src="markdeep-thesis/lib/bindery/2.2.9/bindery.min.js"></script>
<script>
    markdeepThesisOptions = {
        view: "print",
        titlePage: titlePage,
        fontSize: 10.5,
        markdeepDiagramScale: 0.8
    }
</script>
<script src="markdeep-thesis/markdeep-thesis.js"></script>
<script src="markdeep-thesis/lib/markdeep/1.09/markdeep.min.js" charset="utf-8"></script>